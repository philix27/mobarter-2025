// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target x86_64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name ConnectSolanaAdapter
import Accelerate
import Base58_swift
import CommonCrypto
import ConnectCommon
@_exported import ConnectSolanaAdapter
import CryptoSwift
import Foundation
import ParticleNetworkBase
import ParticleNetworkChains
import RxAlamofire
import RxSwift
import Swift
import SwiftyJSON
import SwiftyUserDefaults
import TweetNacl
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import secp256k1
import Accelerate.vecLib
public enum AssociatedTokenProgram : SolanaBasicProgram {
  public static var id: PublicKey {
    get
  }
  public static func createAssociatedTokenAccountInstruction(mint: PublicKey, owner: PublicKey, payer: PublicKey, tokenProgramId: PublicKey) throws -> TransactionInstruction
}
public typealias BlockHash = Swift.String
public struct Message : IMessage, Swift.Equatable {
  public var version: TransactionVersion {
    get
  }
  public var header: MessageHeader {
    get
  }
  public var accountKeys: [PublicKey] {
    get
  }
  public var recentBlockhash: BlockHash {
    get
  }
  public var instructions: [CompiledInstruction] {
    get
  }
  public var staticAccountKeys: [PublicKey] {
    get
  }
  public func serialize() throws -> Foundation.Data
  public static func == (a: Message, b: Message) -> Swift.Bool
}
public class SolanaConnectAdapter : ConnectCommon.ConnectAdapter, ConnectCommon.LocalAdapter {
  public init()
  public var walletType: ConnectCommon.WalletType {
    get
  }
  public func handleUrl(_: Foundation.URL) -> Swift.Bool
  public var readyState: ConnectCommon.WalletReadyState {
    get
  }
  public func getAccounts() -> [ConnectCommon.Account]
  public func connect<T>(_: T? = nil) -> RxSwift.Single<ConnectCommon.Account> where T : ConnectCommon.ConnectConfig
  public func isConnected(publicAddress: Swift.String) -> Swift.Bool
  public func disconnect(publicAddress: Swift.String) -> RxSwift.Single<Swift.String>
  public func signAndSendTransaction(publicAddress: Swift.String, transaction: Swift.String, feeMode _: ParticleNetworkBase.AA.FeeMode, chainInfo _: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  public func signAllTransactions(publicAddress: Swift.String, transactions: [Swift.String], chainInfo _: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<[Swift.String]>
  public func signTransaction(publicAddress: Swift.String, transaction: Swift.String, chainInfo _: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  public func signAllTransactions(publicAddress: Swift.String, transactions: [SolanaVersionedTransaction], chainInfo _: ParticleNetworkChains.ChainInfo? = nil) -> RxSwift.Single<[Swift.String]>
  public func signTransaction(publicAddress: Swift.String, transaction: SolanaVersionedTransaction, chainInfo _: ParticleNetworkChains.ChainInfo? = nil) -> RxSwift.Single<Swift.String>
  public func signMessage(publicAddress: Swift.String, message: Swift.String, chainInfo _: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  public func signTypedData(publicAddress _: Swift.String, data _: Swift.String, chainInfo _: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  public func importWalletFromPrivateKey(_ privateKey: Swift.String) -> RxSwift.Single<ConnectCommon.Account>
  public func importWalletFromMnemonic(_ mnemonic: Swift.String) -> RxSwift.Single<ConnectCommon.Account>
  public func exportWalletPrivateKey(publicAddress: Swift.String) -> RxSwift.Single<Swift.String>
  public func request(publicAddress _: Swift.String, method: Swift.String, parameters: [any Swift.Encodable]) -> RxSwift.Single<SwiftyJSON.JSON>
  @objc deinit
}
public struct TokenAccountState : TokenAccountLayoutState {
  public static let BUFFER_LENGTH: Swift.UInt64
  public let mint: PublicKey
  public let owner: PublicKey
  public let lamports: Swift.UInt64
  public let delegateOption: Swift.UInt32
  public var delegate: PublicKey?
  public let isInitialized: Swift.Bool
  public let isFrozen: Swift.Bool
  public let state: Swift.UInt8
  public let isNativeOption: Swift.UInt32
  public let rentExemptReserve: Swift.UInt64?
  public let isNativeRaw: Swift.UInt64
  public let isNative: Swift.Bool
  public var delegatedAmount: Swift.UInt64
  public let closeAuthorityOption: Swift.UInt32
  public var closeAuthority: PublicKey?
  public init(mint: PublicKey, owner: PublicKey, lamports: Swift.UInt64, delegateOption: Swift.UInt32, delegate: PublicKey? = nil, isInitialized: Swift.Bool, isFrozen: Swift.Bool, state: Swift.UInt8, isNativeOption: Swift.UInt32, rentExemptReserve: Swift.UInt64? = nil, isNativeRaw: Swift.UInt64, isNative: Swift.Bool, delegatedAmount: Swift.UInt64, closeAuthorityOption: Swift.UInt32, closeAuthority: PublicKey? = nil)
  public static func == (a: TokenAccountState, b: TokenAccountState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension TokenAccountState : BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
        self = [Element]()
        self.reserveCapacity(reserveCapacity)
    }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
        self[startIndex ..< endIndex]
    }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
public enum VersionedMessage : Swift.Equatable {
  case legacy(Message)
  case v0(MessageV0)
  public static func deserialize(data: Foundation.Data) throws -> VersionedMessage
  public var value: any IMessage {
    get
  }
  public mutating func setRecentBlockHash(_ blockHash: BlockHash)
  public static func == (a: VersionedMessage, b: VersionedMessage) -> Swift.Bool
}
public protocol BorshDeserializable {
  init(from reader: inout BinaryReader) throws
}
extension Swift.FixedWidthInteger {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.UInt8 : BorshDeserializable {
}
extension Swift.UInt16 : BorshDeserializable {
}
extension Swift.UInt32 : BorshDeserializable {
}
extension Swift.UInt64 : BorshDeserializable {
}
extension UInt2X : BorshDeserializable where Word == Swift.UInt64 {
}
extension Swift.Int8 : BorshDeserializable {
}
extension Swift.Int16 : BorshDeserializable {
}
extension Swift.Int32 : BorshDeserializable {
}
extension Swift.Int64 : BorshDeserializable {
}
extension Int2X : BorshDeserializable where Word == Swift.UInt64 {
}
extension Swift.Float : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Double : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Bool : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.String : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Array : BorshDeserializable where Element : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Set : BorshDeserializable where Element : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
extension Swift.Dictionary : BorshDeserializable where Key : BorshDeserializable, Value : BorshDeserializable {
  public init(from reader: inout BinaryReader) throws
}
public struct Token2022MintState : MintLayoutState {
  public let mintAuthorityOption: Swift.UInt32
  public let mintAuthority: PublicKey?
  public let supply: Swift.UInt64
  public let decimals: Swift.UInt8
  public let isInitialized: Swift.Bool
  public let freezeAuthorityOption: Swift.UInt32
  public let freezeAuthority: PublicKey?
  public var extensions: [AnyToken2022ExtensionState]
  public func getParsedExtension<T>(ofType _: T.Type) -> T? where T : Token2022ExtensionState
  public static func == (a: Token2022MintState, b: Token2022MintState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension Token2022MintState : BorshCodable {
  public init(from reader: inout BinaryReader) throws
  public func serialize(to writer: inout Foundation.Data) throws
}
public struct TransferFeeConfigExtensionState : Token2022ExtensionState {
  public struct TransferFee : BorshCodable, Swift.Codable, Swift.Equatable, Swift.Hashable {
    public let epoch: Swift.UInt64
    public let maximumFee: Swift.UInt64
    public let transferFeeBasisPoints: Swift.UInt16
    public init(from reader: inout BinaryReader) throws
    public func serialize(to data: inout Foundation.Data) throws
    public static func == (a: TransferFeeConfigExtensionState.TransferFee, b: TransferFeeConfigExtensionState.TransferFee) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public let length: Swift.UInt16
  public let transferFeeConfigAuthority: PublicKey
  public let withdrawWithHeldAuthority: PublicKey
  public let withheldAmount: Swift.UInt64
  public let olderTransferFee: TransferFeeConfigExtensionState.TransferFee
  public let newerTransferFee: TransferFeeConfigExtensionState.TransferFee
  public init(from reader: inout BinaryReader) throws
  public func serialize(to data: inout Foundation.Data) throws
  public static func == (a: TransferFeeConfigExtensionState, b: TransferFeeConfigExtensionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct Token2022AccountState : TokenAccountLayoutState {
  public let mint: PublicKey
  public let owner: PublicKey
  public let lamports: Swift.UInt64
  public let delegateOption: Swift.UInt32
  public var delegate: PublicKey?
  public let isInitialized: Swift.Bool
  public let isFrozen: Swift.Bool
  public let state: Swift.UInt8
  public let isNativeOption: Swift.UInt32
  public let rentExemptReserve: Swift.UInt64?
  public let isNativeRaw: Swift.UInt64
  public let isNative: Swift.Bool
  public var delegatedAmount: Swift.UInt64
  public let closeAuthorityOption: Swift.UInt32
  public var closeAuthority: PublicKey?
  public var extensions: [AnyToken2022ExtensionState]
  public init(mint: PublicKey, owner: PublicKey, lamports: Swift.UInt64, delegateOption: Swift.UInt32, delegate: PublicKey? = nil, isInitialized: Swift.Bool, isFrozen: Swift.Bool, state: Swift.UInt8, isNativeOption: Swift.UInt32, rentExemptReserve: Swift.UInt64? = nil, isNativeRaw: Swift.UInt64, isNative: Swift.Bool, delegatedAmount: Swift.UInt64, closeAuthorityOption: Swift.UInt32, closeAuthority: PublicKey? = nil, extensions: [AnyToken2022ExtensionState] = [])
  public static func == (a: Token2022AccountState, b: Token2022AccountState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Token2022AccountState : BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout BinaryReader) throws
}
public enum TransactionVersion : Swift.Equatable {
  case v0
  case legacy
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TransactionVersion, b: TransactionVersion) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SolanaVersionedTransaction : Swift.Equatable {
  public var message: VersionedMessage
  public var signatures: [Foundation.Data] {
    get
  }
  public mutating func setRecentBlockHash(_ blockHash: BlockHash)
  public var version: TransactionVersion {
    get
  }
  public init(message: VersionedMessage, signatures: [Foundation.Data]? = nil)
  public func serialize() throws -> Foundation.Data
  public static func deserialize(data: Foundation.Data) throws -> SolanaVersionedTransaction
  public mutating func sign(signers: [SolanaAccount]) throws
  public mutating func addSignature(publicKey: PublicKey, signature: Foundation.Data) throws
  public static func == (a: SolanaVersionedTransaction, b: SolanaVersionedTransaction) -> Swift.Bool
}
public protocol BytesEncodable {
  var bytes: [Swift.UInt8] { get }
}
extension Swift.UInt8 : BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 : BytesEncodable {
}
extension Swift.UInt32 : BytesEncodable {
}
extension Foundation.Data : BytesEncodable {
}
extension Swift.Bool : BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.Array : BytesEncodable where Element == any BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.RawRepresentable where Self.RawValue == Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.RawRepresentable where Self.RawValue == Swift.UInt8 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
infix operator >>> : BitwiseShiftPrecedence
public enum BinaryReaderError : Swift.Error {
  case invalidBytesCount(Swift.Int)
  case dataMismatch
}
public struct BinaryReader {
  public init(bytes: [Swift.UInt8])
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var remainBytes: Swift.Int {
    get
  }
}
extension BinaryReader {
  public mutating func readAll() throws -> [Swift.UInt8]
  public mutating func read() throws -> Swift.UInt8
  public mutating func read(count: Swift.Int) throws -> [Swift.UInt8]
  public mutating func read(count: Swift.UInt32) throws -> [Swift.UInt8]
  public mutating func decodeLength() throws -> Swift.Int
}
public enum TokenProgram : SolanaTokenProgram {
  public static var id: PublicKey {
    get
  }
}
public protocol Token2022ExtensionState : BorshDeserializable, BorshSerializable, Swift.Decodable, Swift.Encodable, Swift.Hashable {
  var length: Swift.UInt16 { get }
}
extension VecU8 : Token2022ExtensionState where T == Swift.UInt16 {
}
extension Foundation.Data {
  public var decodedLength: Swift.Int {
    get
  }
  public mutating func decodeLength() -> Swift.Int
  public static func encodeLength(_ len: Swift.Int) -> Foundation.Data
}
extension Swift.Encodable {
  public var jsonString: Swift.String? {
    get
  }
}
public struct PublicKey : Swift.Codable, Swift.Equatable, Swift.CustomStringConvertible, Swift.Hashable {
  public static let NULL_PUBLICKEY_BYTES: [Swift.UInt8]
  public static let numberOfBytes: Swift.Int
  public let bytes: [Swift.UInt8]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public init(string: Swift.String?) throws
  public init(data: Foundation.Data) throws
  public init(bytes: [Swift.UInt8]?) throws
  public var base58EncodedString: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public var description: Swift.String {
    get
  }
  public func short(numOfSymbolsRevealed: Swift.Int = 4) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: PublicKey, rhs: PublicKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension PublicKey : BytesEncodable {
}
public enum PublicKeyError : Swift.Error, Swift.Equatable {
  case notFound
  case invalidAddress(Swift.String?)
  case maxSeedLengthExceeded
  case invalidSeed(reason: Swift.String?)
  public static func == (a: PublicKeyError, b: PublicKeyError) -> Swift.Bool
}
extension PublicKey {
  public static func associatedTokenAddress(walletAddress: PublicKey, tokenMintAddress: PublicKey, tokenProgramId: PublicKey) throws -> PublicKey
  public static func findProgramAddress(seeds: [Foundation.Data], programId: PublicKey) throws -> (PublicKey, Swift.UInt8)
  public static func createProgramAddress(seeds: [Foundation.Data], programId: PublicKey) throws -> PublicKey
  public static func createWithSeed(fromPublicKey: PublicKey, seed: Swift.String, programId: PublicKey) throws -> PublicKey
  public static func isOnCurve(publicKey: Swift.String) -> Swift.Int
  public static func isOnCurve(publicKeyBytes: Foundation.Data) -> Swift.Int
}
extension PublicKey {
  public static var sysvarRent: PublicKey {
    get
  }
  public static var wrappedSOLMint: PublicKey {
    get
  }
  public static var solMint: PublicKey {
    get
  }
  public static var swapHostFeeAddress: PublicKey {
    get
  }
  public static var renBTCMint: PublicKey {
    get
  }
  public static var renBTCMintDevnet: PublicKey {
    get
  }
  public static var fake: PublicKey {
    get
  }
  public static func orcaSwapId(version: Swift.Int = 2) -> PublicKey
  public static var usdcMint: PublicKey {
    get
  }
  public static var usdtMint: PublicKey {
    get
  }
  public static var dexPID: PublicKey {
    get
  }
  public static var serumSwapPID: PublicKey {
    get
  }
  public var isUsdx: Swift.Bool {
    get
  }
}
extension PublicKey : BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout BinaryReader) throws
}
public struct AnyToken2022ExtensionState : BorshCodable, Swift.Codable, Swift.Equatable, Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: AnyToken2022ExtensionState, rhs: AnyToken2022ExtensionState) -> Swift.Bool
  public let type: Token2022ExtensionType
  public let state: any Token2022ExtensionState
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from reader: inout BinaryReader) throws
  public func serialize(to data: inout Foundation.Data) throws
  public var hashValue: Swift.Int {
    get
  }
}
public struct MessageAddressTableLookup : Swift.Equatable {
  public let accountKey: PublicKey
  public let writableIndexes: [Swift.UInt8]
  public let readonlyIndexes: [Swift.UInt8]
  public init(accountKey: PublicKey, writableIndexes: [Swift.UInt8], readonlyIndexes: [Swift.UInt8])
  public static func == (a: MessageAddressTableLookup, b: MessageAddressTableLookup) -> Swift.Bool
}
public enum SystemProgram : SolanaBasicProgram {
  public static var id: PublicKey {
    get
  }
  public static func createAccountInstruction(from fromPublicKey: PublicKey, toNewPubkey newPubkey: PublicKey, lamports: Swift.UInt64, space: Swift.UInt64, programId: PublicKey) -> TransactionInstruction
  public static func transferInstruction(from fromPublicKey: PublicKey, to toPublicKey: PublicKey, lamports: Swift.UInt64) -> TransactionInstruction
}
public struct AddressLookupTableState : Swift.Equatable, Swift.Codable, BufferLayout {
  public func serialize(to _: inout Foundation.Data) throws
  public init(from reader: inout BinaryReader) throws
  public static func == (a: AddressLookupTableState, b: AddressLookupTableState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AddressLookupTableAccount : Swift.Equatable {
  public static let lookUpTableMetaSize: Swift.Int
  public let key: PublicKey
  public let state: AddressLookupTableState
  public init(key: PublicKey, state: AddressLookupTableState)
  public static func == (a: AddressLookupTableAccount, b: AddressLookupTableAccount) -> Swift.Bool
}
extension Foundation.Data : BufferLayout, BorshCodable {
  public init(from reader: inout BinaryReader) throws
  public func serialize(to writer: inout Foundation.Data) throws
}
public struct DerivablePath : Swift.Hashable, Swift.Codable {
  public enum DerivableType : Swift.String, Swift.CaseIterable, Swift.Codable {
    case bip44Change
    case bip44
    case deprecated
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DerivablePath.DerivableType]
    public typealias RawValue = Swift.String
    public static var allCases: [DerivablePath.DerivableType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: DerivablePath.DerivableType
  public let walletIndex: Swift.Int
  public let accountIndex: Swift.Int?
  public init(type: DerivablePath.DerivableType, walletIndex: Swift.Int, accountIndex: Swift.Int? = nil)
  public static var `default`: DerivablePath {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DerivablePath, b: DerivablePath) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct CompiledInstruction : Swift.Equatable {
  public let programIdIndex: Swift.UInt8
  public let data: [Swift.UInt8]
  public var accounts: [Swift.Int] {
    get
  }
  public static func == (a: CompiledInstruction, b: CompiledInstruction) -> Swift.Bool
}
extension Swift.String {
  @inlinable public var bytes: [Swift.UInt8] {
    get {
        data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
    }
  }
}
public typealias BorshCodable = BorshDeserializable & BorshSerializable
public enum BorshCodableError : Swift.Error {
  case invalidData
  public static func == (a: BorshCodableError, b: BorshCodableError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Token2022ExtensionType : Swift.UInt16, Swift.Codable, Swift.Hashable {
  case uninitialized
  case transferFeeConfig
  case transferFeeAmount
  case mintCloseAuthority
  case confidentialTransferMint
  case confidentialTransferAccount
  case defaultAccountState
  case immutableOwner
  case memoTransfer
  case nonTransferable
  case interestBearingConfig
  case cpiGuard
  case permanentDelegate
  case nonTransferableAccount
  case transferHook
  case transferHookAccount
  case confidentialTransferFeeConfig
  case confidentialTransferFeeAmount
  case metadataPointer
  case tokenMetadata
  case groupPointer
  case tokenGroup
  case groupMemberPointer
  case tokenGroupMember
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public protocol IMessage {
  var version: TransactionVersion { get }
  var header: MessageHeader { get }
  var recentBlockhash: Swift.String { get }
  func serialize() throws -> Foundation.Data
  var staticAccountKeys: [PublicKey] { get }
}
extension Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 {
  public var bytes: [Swift.UInt8] {
    get
  }
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
}
extension Swift.Double {
  public func toLamport(decimals: Swift.Int) -> Swift.UInt64
  public func toLamport(decimals: Swift.UInt8) -> Swift.UInt64
}
public typealias AccountKeysFromLookups = LoadedAddresses
public struct LoadedAddresses {
  public var readonly: [PublicKey]
  public var writable: [PublicKey]
  public init(readonly: [PublicKey], writable: [PublicKey])
}
public struct MessageAccountKeys {
  public var staticAccountKeys: [PublicKey]
  public var accountKeysFromLookups: AccountKeysFromLookups?
  public init(staticAccountKeys: [PublicKey], accountKeysFromLookups: AccountKeysFromLookups? = nil)
}
public protocol BufferLayout : BorshDeserializable, BorshSerializable, Swift.Decodable, Swift.Encodable, Swift.Equatable {
}
extension BufferLayout {
  public init(from decoder: any Swift.Decoder) throws
}
public protocol BorshSerializable {
  func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.UInt8 : BorshSerializable {
}
extension Swift.UInt16 : BorshSerializable {
}
extension Swift.UInt32 : BorshSerializable {
}
extension Swift.UInt64 : BorshSerializable {
}
extension UInt2X : BorshSerializable where Word == Swift.UInt64 {
}
extension Swift.Int8 : BorshSerializable {
}
extension Swift.Int16 : BorshSerializable {
}
extension Swift.Int32 : BorshSerializable {
}
extension Swift.Int64 : BorshSerializable {
}
extension Int2X : BorshSerializable where Word == Swift.UInt64 {
}
extension Swift.FixedWidthInteger {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Float : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Double : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Bool : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Optional where Wrapped : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.String : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Array : BorshSerializable where Element : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
  public func rawSerialized() throws -> Foundation.Data
}
extension Swift.Set : BorshSerializable where Element : BorshSerializable, Element : Swift.Comparable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Dictionary : BorshSerializable where Key : BorshSerializable, Key : Swift.Comparable, Value : BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
public enum Network : Swift.String, Swift.CaseIterable, Swift.Codable {
  case mainnetBeta
  case devnet
  case testnet
  public var cluster: Swift.String {
    get
  }
  public var isTestnet: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Network]
  public typealias RawValue = Swift.String
  public static var allCases: [Network] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct VecU8<T> : BorshCodable, Swift.Codable, Swift.Equatable, Swift.Hashable where T : Swift.Decodable, T : Swift.Encodable, T : Swift.FixedWidthInteger {
  public let length: T
  public let data: Foundation.Data
  public init(from reader: inout BinaryReader) throws
  public init(length: T, data: Foundation.Data)
  public func serialize(to writer: inout Foundation.Data) throws
  public static func == (a: VecU8<T>, b: VecU8<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum Token2022Program : SolanaTokenProgram {
  public static var id: PublicKey {
    get
  }
}
extension Ed25519HDKey {
  public struct Keys {
    public let key: Foundation.Data
    public let chainCode: Foundation.Data
  }
}
public enum VersionedMessageError : Swift.Error, Swift.Equatable {
  case expectedVersionedMessageButReceivedLegacyMessage
  case invalidMessageVersion(expectedVersion: Swift.UInt8, receivedVersion: Swift.UInt8)
  case deserializationError(Swift.String)
  case other(Swift.String)
  public static func == (a: VersionedMessageError, b: VersionedMessageError) -> Swift.Bool
}
public struct MessageV0 : IMessage, Swift.Equatable {
  public var version: TransactionVersion {
    get
  }
  public var header: MessageHeader
  public var staticAccountKeys: [PublicKey]
  public var recentBlockhash: BlockHash
  public init(header: MessageHeader, staticAccountKeys: [PublicKey], recentBlockhash: BlockHash, compiledInstructions: [MessageCompiledInstruction], addressTableLookups: [MessageAddressTableLookup])
  public var numAccountKeysFromLookups: Swift.Int {
    get
  }
  public func getAccountKeys(accountKeysFromLookups: AccountKeysFromLookups) -> MessageAccountKeys
  public func getAccountKeys(addressLookupTableAccounts: [AddressLookupTableAccount]) throws -> MessageAccountKeys
  public func isAccountSigner(index: Swift.Int) -> Swift.Bool
  public func isAccountWritable(index: Swift.Int) -> Swift.Bool
  public func resolveAddressTableLookups(addressLookupTableAccounts: [AddressLookupTableAccount]) throws -> AccountKeysFromLookups
  public func serialize() throws -> Foundation.Data
  public static func compile(payerKey: PublicKey, instructions: [TransactionInstruction], recentBlockHash: BlockHash, addressLookupTableAccounts: [AddressLookupTableAccount]?) throws -> MessageV0
  public static func deserialize(serializedMessage: Foundation.Data) throws -> MessageV0
  public static func == (a: MessageV0, b: MessageV0) -> Swift.Bool
}
public struct SolanaAccount : Swift.Codable, Swift.Hashable {
  public let phrase: [Swift.String]
  public let publicKey: PublicKey
  public let secretKey: Foundation.Data
  public init(secretKey: Foundation.Data) throws
  #if compiler(>=5.3) && $AsyncAwait
  public init(phrase: [Swift.String] = [], network _: Network, derivablePath: DerivablePath) async throws
  #endif
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SolanaAccount, b: SolanaAccount) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension SolanaAccount {
  public struct Meta : Swift.Equatable, Swift.Codable, Swift.CustomDebugStringConvertible {
    public let publicKey: PublicKey
    public var isSigner: Swift.Bool
    public var isWritable: Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public init(publicKey: PublicKey, isSigner: Swift.Bool, isWritable: Swift.Bool)
    public static func readonly(publicKey: PublicKey, isSigner: Swift.Bool) -> SolanaAccount.Meta
    public static func writable(publicKey: PublicKey, isSigner: Swift.Bool) -> SolanaAccount.Meta
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: SolanaAccount.Meta, b: SolanaAccount.Meta) -> Swift.Bool
  }
}
public protocol TokenAccountLayoutState : BufferLayout {
  var mint: PublicKey { get }
  var owner: PublicKey { get }
  var lamports: Swift.UInt64 { get }
  var delegateOption: Swift.UInt32 { get }
  var delegate: PublicKey? { get set }
  var isInitialized: Swift.Bool { get }
  var isFrozen: Swift.Bool { get }
  var state: Swift.UInt8 { get }
  var isNativeOption: Swift.UInt32 { get }
  var rentExemptReserve: Swift.UInt64? { get }
  var isNativeRaw: Swift.UInt64 { get }
  var isNative: Swift.Bool { get }
  var delegatedAmount: Swift.UInt64 { get set }
  var closeAuthorityOption: Swift.UInt32 { get }
  var closeAuthority: PublicKey? { get set }
}
public protocol MintLayoutState : BufferLayout, Swift.Hashable {
  var mintAuthorityOption: Swift.UInt32 { get }
  var mintAuthority: PublicKey? { get }
  var supply: Swift.UInt64 { get }
  var decimals: Swift.UInt8 { get }
  var isInitialized: Swift.Bool { get }
  var freezeAuthorityOption: Swift.UInt32 { get }
  var freezeAuthority: PublicKey? { get }
}
extension PublicKey : Swift.ExpressibleByStringLiteral, Swift.ExpressibleByUnicodeScalarLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public init(stringLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct MessageHeader : Swift.Decodable, Swift.Equatable {
  public var numRequiredSignatures: Swift.Int {
    get
  }
  public var numReadonlySignedAccounts: Swift.Int {
    get
  }
  public var numReadonlyUnsignedAccounts: Swift.Int {
    get
  }
  public static func == (a: MessageHeader, b: MessageHeader) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct MessageCompiledInstruction : Swift.Equatable {
  public let programIdIndex: Swift.UInt8
  public let accountKeyIndexes: [Swift.UInt8]
  public let data: [Swift.UInt8]
  public init(programIdIndex: Swift.UInt8, accountKeyIndexes: [Swift.UInt8], data: [Swift.UInt8])
  public static func == (a: MessageCompiledInstruction, b: MessageCompiledInstruction) -> Swift.Bool
}
public enum VersionedTransactionError : Swift.Error, Swift.Equatable {
  case nonRequiredSigner(Swift.String)
  case unknownSigner(Swift.String)
  case invalidSigner(Swift.String)
  case noSigner
  case signatureVerificationError
  case signatureNotFound
  case noInstructionProvided
  case feePayerNotFound
  case recentBlockhashNotFound
  case unknown
  public static func == (a: VersionedTransactionError, b: VersionedTransactionError) -> Swift.Bool
}
public typealias UInt1X = Swift.BinaryInteger & Swift.Codable & Swift.FixedWidthInteger & Swift.UnsignedInteger
public struct UInt2X<Word> : Swift.Hashable, Swift.Codable where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger {
  public typealias IntegerLiteralType = Swift.UInt64
  public typealias Magnitude = UInt2X<Word>
  public typealias Words = [Word.Words.Element]
  public typealias Stride = Swift.Int
  public var lo: Word
  public var hi: Word
  public init(hi: Word, lo: Word)
  public init(_ source: UInt2X<Word>)
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension UInt2X {
  public static func == (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> Swift.Bool
}
extension UInt2X : Swift.ExpressibleByIntegerLiteral {
  public static var isSigned: Swift.Bool {
    get
  }
  public static var bitWidth: Swift.Int {
    get
  }
  public static var min: UInt2X<Word> {
    get
  }
  public static var max: UInt2X<Word> {
    get
  }
  public init(_ source: Word)
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init(integerLiteral value: UInt2X<Word>.IntegerLiteralType)
}
extension UInt2X : Swift.Comparable {
  public static func < (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> Swift.Bool
}
public enum Int2XConfig {
  public static var useAccelerate: Swift.Bool
}
extension UInt2X : Swift.Numeric {
  public var magnitude: UInt2X<Word> {
    get
  }
  prefix public static func ~ (value: UInt2X<Word>) -> UInt2X<Word>
  prefix public static func + (value: UInt2X<Word>) -> UInt2X<Word>
  prefix public static func - (value: UInt2X<Word>) -> UInt2X<Word>
  public func addingReportingOverflow(_ other: UInt2X<Word>) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public func addingReportingOverflow(_ other: Word) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public static func &+ (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func + (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func + (lhs: UInt2X<Word>, rhs: Word) -> UInt2X<Word>
  public static func + (lhs: Word, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func += (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func += (lhs: inout UInt2X<Word>, rhs: Word)
  public func subtractingReportingOverflow(_ other: UInt2X<Word>) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: Word) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public static func &- (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func - (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func - (lhs: UInt2X<Word>, rhs: Word) -> UInt2X<Word>
  public static func - (lhs: Word, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func -= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func -= (lhs: inout UInt2X<Word>, rhs: Word)
  public func multipliedHalfWidth(by other: Word) -> (high: UInt2X<Word>, low: UInt2X<Word>.Magnitude)
  public func multipliedFullWidth(by other: UInt2X<Word>) -> (high: UInt2X<Word>, low: UInt2X<Word>.Magnitude)
  public func multipliedReportingOverflow(by other: UInt2X<Word>) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public static func &* (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func &* (lhs: UInt2X<Word>, rhs: Word) -> UInt2X<Word>
  public static func &* (lhs: Word, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func * (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func * (lhs: UInt2X<Word>, rhs: Word) -> UInt2X<Word>
  public static func * (lhs: Word, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func *= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func *= (lhs: inout UInt2X<Word>, rhs: Word)
}
extension UInt2X {
  public func rShifted(_ width: Swift.Int) -> UInt2X<Word>
  public func lShifted(_ width: Swift.Int) -> UInt2X<Word>
  public static func &>> (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func &>>= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func &<< (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func &<<= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
}
extension UInt2X {
  public func quotientAndRemainder(dividingBy other: Word) -> (quotient: UInt2X<Word>, remainder: UInt2X<Word>)
  public func quotientAndRemainder(dividingBy other: UInt2X<Word>) -> (quotient: UInt2X<Word>, remainder: UInt2X<Word>)
  public static func / (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func /= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func % (lhs: UInt2X<Word>, rhs: UInt2X<Word>) -> UInt2X<Word>
  public static func %= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public func dividedReportingOverflow(by other: UInt2X<Word>) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public func remainderReportingOverflow(dividingBy other: UInt2X<Word>) -> (partialValue: UInt2X<Word>, overflow: Swift.Bool)
  public func dividingFullWidth(_ dividend: (high: UInt2X<Word>, low: UInt2X<Word>.Magnitude)) -> (quotient: UInt2X<Word>, remainder: UInt2X<Word>)
}
extension UInt2X : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public func toString(radix: Swift.Int = 10, uppercase: Swift.Bool = false) -> Swift.String
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.StringProtocol {
  public init?<Word>(_ source: UInt2X<Word>, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension UInt2X : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension Swift.Int {
  public init<Word>(_ source: UInt2X<Word>) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension UInt2X : Swift.Strideable {
  public func distance(to other: UInt2X<Word>) -> Swift.Int
  public func advanced(by n: Swift.Int) -> UInt2X<Word>
}
extension UInt2X : Swift.BinaryInteger {
  public var bitWidth: Swift.Int {
    get
  }
  public var words: UInt2X<Word>.Words {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public static func &= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func |= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func ^= (lhs: inout UInt2X<Word>, rhs: UInt2X<Word>)
  public static func <<= <RHS>(lhs: inout UInt2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
  public static func >>= <RHS>(lhs: inout UInt2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
}
extension UInt2X : Swift.FixedWidthInteger {
  public init(_truncatingBits _: Swift.UInt)
  public var nonzeroBitCount: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var byteSwapped: UInt2X<Word> {
    get
  }
}
extension UInt2X : Swift.UnsignedInteger {
}
public typealias UInt128 = UInt2X<Swift.UInt64>
public typealias UInt256 = UInt2X<UInt128>
public typealias UInt512 = UInt2X<UInt256>
public typealias UInt1024 = UInt2X<UInt512>
public protocol SolanaTokenProgram : SolanaBasicProgram {
}
public typealias Lamports = Swift.UInt64
public typealias Decimals = Swift.UInt8
extension SolanaTokenProgram {
  public static var initalizeMintIndex: Swift.UInt8 {
    get
  }
  public static var initializeAccountIndex: Swift.UInt8 {
    get
  }
  public static var transferIndex: Swift.UInt8 {
    get
  }
  public static var approveIndex: Swift.UInt8 {
    get
  }
  public static var mintToIndex: Swift.UInt8 {
    get
  }
  public static var closeAccountIndex: Swift.UInt8 {
    get
  }
  public static var transferCheckedIndex: Swift.UInt8 {
    get
  }
  public static var burnCheckedIndex: Swift.UInt8 {
    get
  }
  public static func initializeMintInstruction(mint: PublicKey, decimals: Swift.UInt8, authority: PublicKey, freezeAuthority: PublicKey?) -> TransactionInstruction
  public static func initializeAccountInstruction(account: PublicKey, mint: PublicKey, owner: PublicKey) -> TransactionInstruction
  public static func transferInstruction(source: PublicKey, destination: PublicKey, owner: PublicKey, amount: Swift.UInt64) -> TransactionInstruction
  public static func transferCheckedInstruction(source: PublicKey, mint: PublicKey, destination: PublicKey, owner: PublicKey, multiSigners: [PublicKey], amount: Lamports, decimals: Decimals) -> TransactionInstruction
  public static func burnCheckedInstruction(mint: PublicKey, account: PublicKey, owner: PublicKey, amount: Swift.UInt64, decimals: Swift.UInt8) -> TransactionInstruction
  public static func approveInstruction(account: PublicKey, delegate: PublicKey, owner: PublicKey, multiSigners: [SolanaAccount], amount: Swift.UInt64) -> TransactionInstruction
  public static func mintToInstruction(mint: PublicKey, destination: PublicKey, authority: PublicKey, amount: Swift.UInt64) -> TransactionInstruction
  public static func closeAccountInstruction(account: PublicKey, destination: PublicKey, owner: PublicKey) -> TransactionInstruction
  public static func closeAccountInstruction(account: PublicKey, destination: PublicKey, owner: PublicKey, signers: [PublicKey]) -> TransactionInstruction
}
public struct TokenMintState : MintLayoutState {
  public static var BUFFER_LENGTH: Swift.UInt64
  public let mintAuthorityOption: Swift.UInt32
  public let mintAuthority: PublicKey?
  public let supply: Swift.UInt64
  public let decimals: Swift.UInt8
  public let isInitialized: Swift.Bool
  public let freezeAuthorityOption: Swift.UInt32
  public let freezeAuthority: PublicKey?
  public static func == (a: TokenMintState, b: TokenMintState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension TokenMintState : BorshCodable {
  public init(from reader: inout BinaryReader) throws
  public func serialize(to writer: inout Foundation.Data) throws
}
public typealias Int1X = Swift.BinaryInteger & Swift.Codable & Swift.FixedWidthInteger & Swift.SignedInteger
public struct Int2X<Word> : Swift.Hashable, Swift.Codable where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger {
  public typealias IntegerLiteralType = Swift.UInt64
  public typealias Magnitude = UInt2X<Word>
  public typealias Words = [Word.Words.Element]
  public typealias Stride = Swift.Int
  public var rawValue: Int2X<Word>.Magnitude
  public init(rawValue: Int2X<Word>.Magnitude)
  public init(_ source: Int2X<Word>)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension Int2X {
  public static func == (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Swift.Bool
}
extension Int2X : Swift.ExpressibleByIntegerLiteral {
  public static var isSigned: Swift.Bool {
    get
  }
  public static var bitWidth: Swift.Int {
    get
  }
  public static var max: Int2X<Word> {
    get
  }
  public static var min: Int2X<Word> {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init(integerLiteral value: Int2X<Word>.IntegerLiteralType)
}
extension Int2X : Swift.Comparable {
  public var magnitude: Int2X<Word>.Magnitude {
    get
  }
  public static func < (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Swift.Bool
}
extension Int2X : Swift.Numeric {
  prefix public static func ~ (value: Int2X<Word>) -> Int2X<Word>
  prefix public static func + (value: Int2X<Word>) -> Int2X<Word>
  prefix public static func - (value: Int2X<Word>) -> Int2X<Word>
  public func addingReportingOverflow(_ other: Int2X<Word>) -> (partialValue: Int2X<Word>, overflow: Swift.Bool)
  public static func &+ (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func + (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func += (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public func subtractingReportingOverflow(_ other: Int2X<Word>) -> (partialValue: Int2X<Word>, overflow: Swift.Bool)
  public static func &- (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func - (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func -= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public func multipliedFullWidth(by other: Int2X<Word>) -> (high: Int2X<Word>, low: Int2X<Word>.Magnitude)
  public func multipliedReportingOverflow(by other: Int2X<Word>) -> (partialValue: Int2X<Word>, overflow: Swift.Bool)
  public static func &* (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func * (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func *= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
}
extension Int2X {
  public static func &>> (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func &<< (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func &>>= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public static func &<<= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
}
extension Int2X {
  public func quotientAndRemainder(dividingBy other: Int2X<Word>) -> (quotient: Int2X<Word>, remainder: Int2X<Word>)
  public static func / (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func /= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public static func % (lhs: Int2X<Word>, rhs: Int2X<Word>) -> Int2X<Word>
  public static func %= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public func dividedReportingOverflow(by other: Int2X<Word>) -> (partialValue: Int2X<Word>, overflow: Swift.Bool)
  public func remainderReportingOverflow(dividingBy other: Int2X<Word>) -> (partialValue: Int2X<Word>, overflow: Swift.Bool)
  public func dividingFullWidth(_ dividend: (high: Int2X<Word>, low: Int2X<Word>.Magnitude)) -> (quotient: Int2X<Word>, remainder: Int2X<Word>)
}
extension Int2X : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public func toString(radix: Swift.Int = 10, uppercase: Swift.Bool = false) -> Swift.String
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.StringProtocol {
  public init?<Word>(_ source: Int2X<Word>, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension Int2X : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension Swift.Int {
  public init<Word>(_ source: Int2X<Word>) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension Int2X : Swift.Strideable {
  public func distance(to other: Int2X<Word>) -> Swift.Int
  public func advanced(by n: Swift.Int) -> Int2X<Word>
}
extension Int2X : Swift.BinaryInteger {
  public var bitWidth: Swift.Int {
    get
  }
  public var words: Int2X<Word>.Words {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public static func &= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public static func |= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public static func ^= (lhs: inout Int2X<Word>, rhs: Int2X<Word>)
  public static func <<= <RHS>(lhs: inout Int2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
  public static func >>= <RHS>(lhs: inout Int2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
}
extension Int2X : Swift.FixedWidthInteger {
  public init(_truncatingBits _: Swift.UInt)
  public var nonzeroBitCount: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var byteSwapped: Int2X<Word> {
    get
  }
}
extension Int2X : Swift.SignedInteger {
}
public typealias Int128 = Int2X<Swift.UInt64>
public typealias Int256 = Int2X<UInt128>
public typealias Int512 = Int2X<UInt256>
public typealias Int1024 = Int2X<UInt512>
public struct InterestBearingConfigExtensionState : Token2022ExtensionState {
  public var length: Swift.UInt16
  public let rateAuthority: PublicKey
  public let initializationTimestamp: Swift.Int64
  public let preUpdateAverageRate: Swift.Int16
  public let lastUpdateTimestamp: Swift.Int64
  public let currentRate: Swift.Int16
  public init(from reader: inout BinaryReader) throws
  public func serialize(to data: inout Foundation.Data) throws
  public static func == (a: InterestBearingConfigExtensionState, b: InterestBearingConfigExtensionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public protocol SolanaBasicProgram {
  static var id: PublicKey { get }
}
public struct TransactionInstruction : Swift.Codable, Swift.Equatable {
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: TransactionInstruction, b: TransactionInstruction) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: [Swift.UInt8] {
    get
  }
  public func toHexString() -> Swift.String
  public func sha256() -> Foundation.Data
}
public enum Ed25519HDKey {
  public typealias Hex = Swift.String
  public typealias Path = Swift.String
  public enum Error : Swift.Error {
    case invalidDerivationPath
    case hmacCanNotAuthenticate
    case canNotGetMasterKeyFromSeed
    public static func == (a: Ed25519HDKey.Error, b: Ed25519HDKey.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let hardenedOffset: Swift.Int
  public static func getMasterKeyFromSeed(_ seed: Ed25519HDKey.Hex) -> Swift.Result<Ed25519HDKey.Keys, Ed25519HDKey.Error>
  public static func getPublicKey(privateKey: Foundation.Data, withZeroBytes: Swift.Bool = true) throws -> Foundation.Data
  public static func derivePath(_ path: Ed25519HDKey.Path, seed: Ed25519HDKey.Hex, offSet: Swift.Int = hardenedOffset) -> Swift.Result<Ed25519HDKey.Keys, Ed25519HDKey.Error>
}
public struct EmptyInfo : BufferLayout {
  public static var BUFFER_LENGTH: Swift.UInt64
  public init()
  public static func == (a: EmptyInfo, b: EmptyInfo) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension EmptyInfo : BorshCodable {
  public init(from _: inout BinaryReader) throws
  public func serialize(to _: inout Foundation.Data) throws
}
public func sha256(data: Foundation.Data) -> Foundation.Data
public struct TransactionMessage {
}
public struct SolanaTransaction : Swift.Encodable, Swift.Equatable {
  public var signatures: [Signature]
  public var feePayer: PublicKey?
  public var instructions: [TransactionInstruction]
  public var recentBlockhash: Swift.String?
  public init()
  public init(instructions: [TransactionInstruction], recentBlockhash: Swift.String? = nil, feePayer: PublicKey? = nil)
  public mutating func serialize(requiredAllSignatures: Swift.Bool = true, verifySignatures: Swift.Bool = false) throws -> Foundation.Data
  public mutating func _addSignature(_ signature: Signature) throws
  public mutating func compile() throws -> Message
  public static func from(data: Foundation.Data) throws -> SolanaTransaction
  public static func == (a: SolanaTransaction, b: SolanaTransaction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct Signature : Swift.Encodable, Swift.Equatable {
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: Signature, b: Signature) -> Swift.Bool
}
extension TransactionVersion : Swift.Hashable {}
extension DerivablePath.DerivableType : Swift.Equatable {}
extension DerivablePath.DerivableType : Swift.Hashable {}
extension DerivablePath.DerivableType : Swift.RawRepresentable {}
extension BorshCodableError : Swift.Equatable {}
extension BorshCodableError : Swift.Hashable {}
extension Token2022ExtensionType : Swift.RawRepresentable {}
extension Network : Swift.Equatable {}
extension Network : Swift.Hashable {}
extension Network : Swift.RawRepresentable {}
extension Ed25519HDKey.Error : Swift.Equatable {}
extension Ed25519HDKey.Error : Swift.Hashable {}
