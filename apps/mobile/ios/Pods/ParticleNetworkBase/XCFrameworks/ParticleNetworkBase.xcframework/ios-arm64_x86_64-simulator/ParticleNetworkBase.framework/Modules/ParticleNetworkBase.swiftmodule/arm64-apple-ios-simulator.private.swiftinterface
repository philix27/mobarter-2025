// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name ParticleNetworkBase
import Alamofire
import Base58_swift
import CryptoSwift
import Foundation
import ParticleNetworkChains
import RxAlamofire
import RxSwift
import SafariServices
import Swift
import SwiftyJSON
import SwiftyUserDefaults
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@objc public enum SocialLoginPrompt : Swift.Int, Swift.RawRepresentable {
  case null
  case none
  case consent
  case selectAccount
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIColor {
  public enum WLNewColor {
    case bg
    case addressBg
    case shadowColor
    case textBg
    case alertBg
    case iconBg
    case separateLine
    case secondaryBg
    case secondaryTextBg
    case alertTextBg
    case thirdBg
    case buttonBg
    case buttonTextColor
    case grayButtonBg
    case grayButtonTextColor
    case disableButtonBg
    case nftDetailButtonBg
    case text
    case grayText
    case lightGrayText
    case didGreen
    case didBlue
    case didOrange
    case didPurple
    case error
    case success
    case swapCardBg
    case shadowPurple
    case shadowGreen
    case infoBg
    case skeletonColor
    case keyboardEdge
    case recommended
    public static func == (a: UIKit.UIColor.WLNewColor, b: UIKit.UIColor.WLNewColor) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func selectNewColor(_ color: UIKit.UIColor.WLNewColor, alpha: CoreFoundation.CGFloat = 1.0, forceMode: UIKit.UIUserInterfaceStyle? = nil) -> UIKit.UIColor
}
extension UIKit.UIColor {
  @frozen public enum ThemeColor {
    case current
    case theme0
    case theme1
    case theme2
    case theme3
    case theme4
    case theme5
    case theme6
    case theme7
    case theme8
    case theme9
    case theme10
    public static func == (a: UIKit.UIColor.ThemeColor, b: UIKit.UIColor.ThemeColor) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func selectTheme(_ color: UIKit.UIColor.ThemeColor) -> UIKit.UIColor
}
extension UIKit.UIColor {
  public func image(_ size: CoreFoundation.CGSize = CGSize(width: 1, height: 1)) -> UIKit.UIImage
}
extension UIKit.UIColor {
  convenience public init?(hex: Swift.String, transparency: CoreFoundation.CGFloat = 1)
  convenience public init?(red: Swift.Int, green: Swift.Int, blue: Swift.Int, transparency: CoreFoundation.CGFloat = 1)
  public var rgbaDescription: Swift.String? {
    get
  }
  convenience public init?(rgbaDescription: Swift.String)
}
public protocol AAServiceProtocol {
  func rpcGetSmartAccount(eoaAddresses: [Swift.String], chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<[AA.SmartAccountInfo]>
  func rpcGetFeeQuotes(eoaAddress: Swift.String, transactions: [Swift.String], chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<AA.WholeFeeQuote>
  func rpcCreateUserOp(eoaAddress: Swift.String, transactions: [Swift.String], feeQuote: AA.FeeQuote, tokenPaymasterAddress: Swift.String, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<AA.UserOp>
  func rpcSendUserOp(eoaAddress: Swift.String, userOp: SwiftyJSON.JSON, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isDeploy(eoaAddress: Swift.String, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.Bool>
  func deployWalletContract(messageSigner: any MessageSigner, feeMode: AA.FeeMode, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isAAModeEnable() -> Swift.Bool
  func enableAAMode()
  func disableAAMode()
  func getSmartAccount(by eosAddress: Swift.String, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<AA.SmartAccountInfo>
  func getSmartAccounts(by publicAddresses: [Swift.String], chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<[AA.SmartAccountInfo]>
  func quickSendTransactions(_ transactions: [Swift.String], feeMode: AA.FeeMode, messageSigner: any MessageSigner, wholeFeeQuote: AA.WholeFeeQuote?, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isSupportChainInfo(_ chainInfo: ParticleNetworkChains.ChainInfo) -> Swift.Bool
  func getSupportChainInfos() -> [ParticleNetworkChains.ChainInfo]
}
public protocol MessageSigner {
  func signMessage(_ message: Swift.String, chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Swift.String>
  func getEoaAddress() -> Swift.String
}
extension ParticleNetwork {
  public struct ResponseError : Swift.Codable, Swift.Equatable, Swift.Error, Swift.CustomStringConvertible {
    public let code: Swift.Int?
    public let message: Swift.String?
    public var data: Swift.String?
    public static func == (lhs: ParticleNetwork.ResponseError, rhs: ParticleNetwork.ResponseError) -> Swift.Bool
    public init(code: Swift.Int?, message: Swift.String?, data: Swift.String? = nil)
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case code, message, data
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public init(from decoder: any Swift.Decoder) throws
    public var description: Swift.String {
      get
    }
    public var localizedDescription: Swift.String {
      get
    }
    public static let userNotLogin: ParticleNetwork.ResponseError
    public static let parseError: ParticleNetwork.ResponseError
    public static let invalidRequest: ParticleNetwork.ResponseError
    public static let methodNotFound: ParticleNetwork.ResponseError
    public static let invalidParameters: ParticleNetwork.ResponseError
    public static let internalError: ParticleNetwork.ResponseError
    public static let serverError: ParticleNetwork.ResponseError
    public static let userCancel: ParticleNetwork.ResponseError
    public static let masterPasswordRestoreError: ParticleNetwork.ResponseError
    public static let biometricDecryptFailed: ParticleNetwork.ResponseError
    public static let invalidPhoneNumber: ParticleNetwork.ResponseError
    public static let invalidEmailAddress: ParticleNetwork.ResponseError
    public static let noTopMostVc: ParticleNetwork.ResponseError
    public static let nullResult: ParticleNetwork.ResponseError
    public func encode(to encoder: any Swift.Encoder) throws
  }
}
public typealias Limbs = [Swift.UInt64]
public typealias Limb = Swift.UInt64
public typealias Digits = [Swift.UInt64]
public typealias Digit = Swift.UInt64
public typealias Bytes = [Swift.UInt8]
public typealias Byte = Swift.UInt8
precedencegroup ExponentiationPrecedence {
  associativity: left
  higherThan: MultiplicationPrecedence
  lowerThan: BitwiseShiftPrecedence
}
infix operator ** : ExponentiationPrecedence
public struct BInt : Swift.SignedNumeric, Swift.BinaryInteger, Swift.ExpressibleByFloatLiteral, Swift.Codable {
  public typealias Magnitude = BInt
  public var magnitude: BInt {
    get
  }
  public typealias Words = [Swift.UInt]
  public var words: BInt.Words {
    get
  }
  public var size: Swift.Int {
    get
  }
  public var sizeDescription: Swift.String {
    get
  }
  public static var stringPrefixes: [Swift.Int : Swift.String]
  public init(_ z: Swift.Int)
  public init(_ n: Swift.UInt)
  public init?(_ number: Swift.String, radix: Swift.Int = 10)
  public init(floatLiteral value: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init(bytes: Bytes)
  public var description: Swift.String {
    get
  }
  public func asString(radix: Swift.Int) -> Swift.String
  public func asInt() -> Swift.Int?
  public var rawValue: (sign: Swift.Bool, limbs: [Swift.UInt64]) {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static var isSigned: Swift.Bool {
    get
  }
  public var bitWidth: Swift.Int {
    get
  }
  public func signum() -> BInt
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public func getBytes() -> Bytes
  public static func << <T>(lhs: BInt, rhs: T) -> BInt where T : Swift.BinaryInteger
  public static func <<= <T>(lhs: inout BInt, rhs: T) where T : Swift.BinaryInteger
  public static func >> <T>(lhs: BInt, rhs: T) -> BInt where T : Swift.BinaryInteger
  public static func >>= <T>(lhs: inout BInt, rhs: T) where T : Swift.BinaryInteger
  public static func & (lhs: BInt, rhs: BInt) -> BInt
  public static func &= (lhs: inout BInt, rhs: BInt)
  public static func | (lhs: BInt, rhs: BInt) -> BInt
  public static func |= (lhs: inout BInt, rhs: BInt)
  public static func ^ (lhs: BInt, rhs: BInt) -> BInt
  public static func ^= (lhs: inout BInt, rhs: BInt)
  prefix public static func ~ (x: BInt) -> BInt
  prefix public static func + (x: BInt) -> BInt
  public static func += (lhs: inout BInt, rhs: BInt)
  public static func + (lhs: BInt, rhs: BInt) -> BInt
  public static func + (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func + (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func += (lhs: inout Swift.Int, rhs: BInt)
  public static func += (lhs: inout BInt, rhs: Swift.Int)
  public mutating func negate()
  prefix public static func - (n: BInt) -> BInt
  public static func - (lhs: BInt, rhs: BInt) -> BInt
  public static func - (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func - (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func -= (lhs: inout BInt, rhs: BInt)
  public static func -= (lhs: inout Swift.Int, rhs: BInt)
  public static func -= (lhs: inout BInt, rhs: Swift.Int)
  public static func * (lhs: BInt, rhs: BInt) -> BInt
  public static func * (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func * (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func *= (lhs: inout BInt, rhs: BInt)
  public static func *= (lhs: inout Swift.Int, rhs: BInt)
  public static func *= (lhs: inout BInt, rhs: Swift.Int)
  public static func ** (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func ** (lhs: BInt, rhs: BInt) -> BInt
  public func factorial() -> BInt
  public func quotientAndRemainder(dividingBy rhs: BInt) -> (quotient: BInt, remainder: BInt)
  public static func / (lhs: BInt, rhs: BInt) -> BInt
  public static func /= (lhs: inout BInt, rhs: BInt)
  public static func % (lhs: BInt, rhs: BInt) -> BInt
  public static func %= (lhs: inout BInt, rhs: BInt)
  public static func == (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func < (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func > (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func <= (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func >= (lhs: BInt, rhs: BInt) -> Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public typealias Stride = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct BDouble : Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.CustomStringConvertible, Swift.SignedNumeric, Swift.Comparable, Swift.Hashable, Swift.Codable {
  public var sign: Swift.Bool {
    get
  }
  public var numerator: Limbs {
    get
  }
  public var denominator: Limbs {
    get
  }
  public typealias Magnitude = Swift.Double
  public var magnitude: Swift.Double
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init(_ src: BInt)
  public init(sign: Swift.Bool, numerator: Limbs, denominator: Limbs)
  public init(_ numerator: BInt, over denominator: BInt)
  public init(_ numerator: Swift.Int, over denominator: Swift.Int)
  public init?(_ numerator: Swift.String, over denominator: Swift.String)
  public init?(_ nStr: Swift.String)
  public init?(_ nStr: Swift.String, radix: Swift.Int)
  public init(_ z: Swift.Int)
  public init(_ d: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public var description: Swift.String {
    get
  }
  public var fractionDescription: Swift.String {
    get
  }
  public static var precision: Swift.Int {
    get
    set
  }
  public var precision: Swift.Int {
    get
    set
  }
  public var decimalDescription: Swift.String {
    get
  }
  public func decimalExpansion(precisionAfterDecimalPoint precision: Swift.Int, rounded: Swift.Bool = true) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var size: Swift.Int {
    get
  }
  public var sizeDescription: Swift.String {
    get
  }
  public func rawData() -> (sign: Swift.Bool, numerator: [Swift.UInt64], denominator: [Swift.UInt64])
  public func isPositive() -> Swift.Bool
  public func isNegative() -> Swift.Bool
  public func isZero() -> Swift.Bool
  public mutating func minimize()
  public func rounded() -> BInt
  public func nthroot(_ root: Swift.Int) -> BDouble
  public func squareRoot() -> BDouble
  public static func + (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func + (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func + (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func + (lhs: BDouble, rhs: BInt) -> BDouble
  public static func + (lhs: BInt, rhs: BDouble) -> BDouble
  public static func += (lhs: inout BDouble, rhs: BDouble)
  public static func += (lhs: inout BDouble, rhs: Swift.Double)
  public mutating func negate()
  prefix public static func - (n: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func - (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: BInt) -> BDouble
  public static func -= (lhs: inout BDouble, rhs: BDouble)
  public static func -= (lhs: inout BDouble, rhs: Swift.Double)
  public static func * (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func * (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func * (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func * (lhs: BDouble, rhs: BInt) -> BDouble
  public static func * (lhs: BInt, rhs: BDouble) -> BDouble
  public static func *= (lhs: inout BDouble, rhs: BDouble)
  public static func *= (lhs: inout BDouble, rhs: Swift.Double)
  public static func ** (base: BDouble, exponent: Swift.Int) -> BDouble
  public static func ** (base: BDouble, exponent: BInt) -> BDouble
  public static func ** (base: BDouble, exponent: BDouble) -> BDouble
  public static func / (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func / (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func / (lhs: BDouble, rhs: BInt) -> BDouble
  public static func / (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func % (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func % (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func % (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func nearlyEqual(_ lhs: BDouble, _ rhs: BDouble, epsilon: Swift.Double = 0.00001) -> Swift.Bool
  public static func == (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func == (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func == (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func != (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func != (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func != (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func < (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func < (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func < (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func > (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func > (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func > (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func <= (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func <= (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func <= (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func >= (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func >= (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func >= (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public func abs(_ x: BDouble) -> BDouble
public func floor(_ base: BDouble) -> BInt
public func ceil(_ base: BDouble) -> BInt
public func pow(_ base: BDouble, _ exp: Swift.Int) -> BDouble
public func pow(_ base: BDouble, _ exp: BInt) -> BDouble
public func pow(_ base: BDouble, _ exp: BDouble) -> BDouble
public func min(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public func max(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public func mod(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public protocol TxDataCodable : Swift.Decodable, Swift.Encodable {
  func serialize() throws -> Swift.String
  init?(_ hexString: Swift.String) throws
}
extension TxDataCodable {
  public func serialize() throws -> Swift.String
  public init?(_ hexString: Swift.String) throws
}
@objc public enum Action : Swift.Int, Swift.RawRepresentable, Swift.Codable {
  case normal
  case speedup
  case cancel
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum GasLevel : Swift.Int, Swift.RawRepresentable, Swift.Codable {
  case none = 0
  case custom
  case low
  case medium
  case high
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc final public class FeeMarketEIP1559TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let maxPriorityFeePerGas: Swift.String
  final public let maxFeePerGas: Swift.String
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(maxPriorityFeePerGas: Swift.String, maxFeePerGas: Swift.String, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = Action.normal, gasLevel: GasLevel = GasLevel.none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc final public class AccessListEIP2930TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let gasPrice: Swift.String
  final public let accessList: AccessList?
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(gasPrice: Swift.String, accessList: AccessList?, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = .normal, gasLevel: GasLevel = .none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc public class AccessList : ObjectiveC.NSObject, Swift.Codable {
  @objc public init(address: Swift.String, storageKeys: [Swift.String])
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@objc final public class TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let gasPrice: Swift.String
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(gasPrice: Swift.String, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = .normal, gasLevel: GasLevel = .none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum Language : Swift.String, Swift.CaseIterable {
  case en
  case zh_Hans
  case zh_Hant
  case ja
  case ko
  public var localString: Swift.String {
    get
  }
  public var webString: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Language]
  public typealias RawValue = Swift.String
  public static var allCases: [Language] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@frozen @objc public enum LoginType : Swift.Int, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case email
  case phone
  case google
  case facebook
  case apple
  case twitter
  case discord
  case github
  case twitch
  case microsoft
  case linkedin
  case jwt
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [LoginType]
  public static var allCases: [LoginType] {
    get
  }
}
extension LoginType : SwiftyUserDefaults.DefaultsSerializable {
  public static var _defaults: SwiftyUserDefaults.DefaultsCodableBridge<LoginType> {
    get
  }
  public static var _defaultsArray: SwiftyUserDefaults.DefaultsCodableBridge<[LoginType]> {
    get
  }
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[LoginType]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<LoginType>
}
public typealias Decimals = Swift.UInt8
public struct Request : Swift.Encodable {
  public init(method: Swift.String, params: [any Swift.Encodable], id: Swift.String = UUID().uuidString, jsonrpc: Swift.String = "2.0")
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct EncodableWrapper : Swift.Encodable {
  public init(wrapped: any Swift.Encodable)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct Response<T> : Swift.Decodable where T : Swift.Decodable {
  public let chainId: Swift.Int?
  public let jsonrpc: Swift.String
  public let id: Swift.String?
  public let result: T?
  public var error: ParticleNetwork.ResponseError?
  public let method: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case chainId, jsonrpc, id, result, error, method
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct SecurityAccountConfig : Swift.Encodable {
  public var promptSettingWhenSign: Swift.Int
  public var promptMasterPasswordSettingWhenLogin: Swift.Int
  public init(promptSettingWhenSign: Swift.Int = 1, promptMasterPasswordSettingWhenLogin: Swift.Int = 0)
  public func encode(to encoder: any Swift.Encoder) throws
}
final public class User : Swift.Codable, Swift.Equatable, SwiftyUserDefaults.DefaultsSerializable {
  final public let token: Swift.String
  final public let uuid: Swift.String
  final public let deviceId: Swift.String
  final public let wallets: [Wallet]
  final public var securityAccount: SecurityAccount?
  final public var avatar: Swift.String?
  final public var createdAt: Swift.String?
  final public var updateAt: Swift.String?
  final public var email: Swift.String?
  final public var appleEmail: Swift.String?
  final public var appleId: Swift.String?
  final public var facebookEmail: Swift.String?
  final public var facebookId: Swift.String?
  final public var googleEmail: Swift.String?
  final public var googleId: Swift.String?
  final public var name: Swift.String?
  final public var phone: Swift.String?
  final public var twitterId: Swift.String?
  final public var twitterEmail: Swift.String?
  final public var discordId: Swift.String?
  final public var discordEmail: Swift.String?
  final public var githubId: Swift.String?
  final public var githubEmail: Swift.String?
  final public var twitchId: Swift.String?
  final public var twitchEmail: Swift.String?
  final public var microsoftId: Swift.String?
  final public var microsoftEmail: Swift.String?
  final public var linkedinId: Swift.String?
  final public var linkedinEmail: Swift.String?
  final public var thirdParty: ThirdParty?
  final public var signature: Swift.String?
  final public var message: Swift.String?
  final public var jwtId: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
  public init(deviceId: Swift.String, token: Swift.String, uuid: Swift.String, wallets: [Wallet])
  public static func == (lhs: User, rhs: User) -> Swift.Bool
  public struct UserSnakeCase : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[User]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<User>
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
final public class SecurityAccount : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
  final public var email: Swift.String?
  final public var phone: Swift.String?
  final public var hasSetPaymentPassword: Swift.Bool
  final public var hasSetMasterPassword: Swift.Bool
  public init(email: Swift.String?, phone: Swift.String?, hasSetPaymentPassword: Swift.Bool, hasSetMasterPassword: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[SecurityAccount]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<SecurityAccount>
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
final public class Wallet : Swift.Encodable, Swift.Decodable, Swift.Equatable, SwiftyUserDefaults.DefaultsSerializable {
  final public let uuid: Swift.String
  final public let chainName: Swift.String
  final public let publicAddress: Swift.String
  public static func == (lhs: Wallet, rhs: Wallet) -> Swift.Bool
  public init(uuid: Swift.String, chainName: Swift.String, publicAddress: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[Wallet]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<Wallet>
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
final public class ThirdParty : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
  final public var provider: Swift.String?
  final public var userInfo: ThirdParty.UserInfo?
  public class UserInfo : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
    public var id: Swift.String?
    public var name: Swift.String?
    public var email: Swift.String?
    public var picture: Swift.String?
    public init(id: Swift.String?, name: Swift.String?, email: Swift.String?, picture: Swift.String?)
    required public init(from decoder: any Swift.Decoder) throws
    public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[ThirdParty.UserInfo]>
    public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<ThirdParty.UserInfo>
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public init(provider: Swift.String?, userInfo: ThirdParty.UserInfo?)
  public init(from decoder: any Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[ThirdParty]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<ThirdParty>
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
@objc public class UserInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc public var token: Swift.String
  @objc final public let uuid: Swift.String
  @objc final public let wallets: [WalletInfo]
  @objc public var securityAccount: SecurityAccountInfo?
  @objc final public let avatar: Swift.String?
  @objc final public let createdAt: Swift.String?
  @objc final public let updatedAt: Swift.String?
  @objc final public let email: Swift.String?
  @objc final public let appleEmail: Swift.String?
  @objc final public let appleId: Swift.String?
  @objc final public let facebookEmail: Swift.String?
  @objc final public let facebookId: Swift.String?
  @objc final public let googleEmail: Swift.String?
  @objc final public let googleId: Swift.String?
  @objc final public let name: Swift.String?
  @objc final public let phone: Swift.String?
  @objc public var twitterId: Swift.String?
  @objc public var twitterEmail: Swift.String?
  @objc final public let discordId: Swift.String?
  @objc final public let discordEmail: Swift.String?
  @objc final public let githubId: Swift.String?
  @objc final public let githubEmail: Swift.String?
  @objc final public let twitchId: Swift.String?
  @objc final public let twitchEmail: Swift.String?
  @objc final public let microsoftId: Swift.String?
  @objc final public let microsoftEmail: Swift.String?
  @objc final public let linkedinId: Swift.String?
  @objc final public let linkedinEmail: Swift.String?
  @objc public var thirdParty: ThirdPartyWarpper?
  @objc public var signature: Swift.String?
  @objc public var message: Swift.String?
  @objc public var jwtId: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuid, phone, email, name, avatar, signature, message
    case createdAt
    case updatedAt
    case facebookId
    case facebookEmail
    case googleId
    case googleEmail
    case appleId
    case appleEmail
    case twitterId
    case twitterEmail
    case discordId
    case discordEmail
    case githubId
    case githubEmail
    case twitchId
    case twitchEmail
    case microsoftId
    case microsoftEmail
    case linkedinId
    case linkedinEmail
    case thirdParty
    case wallets
    case token
    case securityAccount
    case jwtId
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(token: Swift.String, uuid: Swift.String, wallets: [WalletInfo], securityAccount: SecurityAccountInfo?, avatar: Swift.String?, createdAt: Swift.String?, updatedAt: Swift.String?, email: Swift.String?, appleEmail: Swift.String?, appleId: Swift.String?, facebookEmail: Swift.String?, facebookId: Swift.String?, googleEmail: Swift.String?, googleId: Swift.String?, name: Swift.String?, phone: Swift.String?, twitterId: Swift.String?, twitterEmail: Swift.String?, discordId: Swift.String?, discordEmail: Swift.String?, githubId: Swift.String?, githubEmail: Swift.String?, twitchId: Swift.String?, twitchEmail: Swift.String?, microsoftId: Swift.String?, microsoftEmail: Swift.String?, linkedinId: Swift.String?, linkedinEmail: Swift.String?, thirdParty: ThirdPartyWarpper?, signature: Swift.String?, message: Swift.String?, jwtId: Swift.String?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public func convertToSnakeCase() -> User.UserSnakeCase
  public func jsonStringFullSnake() -> Swift.String
  public func jsonStringSnake() -> Swift.String?
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@objc public class SecurityAccountInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc public var email: Swift.String?
  @objc public var phone: Swift.String?
  @objc public var hasSetPaymentPassword: Swift.Bool
  @objc public var hasSetMasterPassword: Swift.Bool
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case email, phone
    case hasSetMasterPassword
    case hasSetPaymentPassword
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(email: Swift.String?, phone: Swift.String?, hasSetPaymentPassword: Swift.Bool, hasSetMasterPassword: Swift.Bool)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@objc public class WalletInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let uuid: Swift.String
  @objc final public let chainName: Swift.String
  @objc final public let publicAddress: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuid
    case chainName
    case publicAddress
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  required public init(from decoder: any Swift.Decoder) throws
  @objc public init(uuid: Swift.String, chainName: Swift.String, publicAddress: Swift.String)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc public class ThirdPartyWarpper : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let provider: Swift.String?
  @objc final public let userInfo: ThirdPartyUserInfoWarpper?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case provider
    case userInfo
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(provider: Swift.String?, userInfo: ThirdPartyUserInfoWarpper?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@objc public class ThirdPartyUserInfoWarpper : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let id: Swift.String?
  @objc final public let name: Swift.String?
  @objc final public let email: Swift.String?
  @objc final public let picture: Swift.String?
  @objc public init(id: Swift.String?, name: Swift.String?, email: Swift.String?, picture: Swift.String?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@frozen public enum ImagePath {
  case url(Swift.String)
  case local(UIKit.UIImage)
  case data(Swift.String)
}
public struct LoginPageConfig {
  public var imagePath: ImagePath
  public var projectName: Swift.String
  public var description: Swift.String
  public init(imagePath: ImagePath, projectName: Swift.String, description: Swift.String)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var navigationBarHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public class var topMost: UIKit.UIViewController? {
    get
  }
}
@objc public class LoginAuthorization : ObjectiveC.NSObject {
  final public let message: Swift.String?
  final public let isUnique: Swift.Bool?
  public init(message: Swift.String?, isUnique: Swift.Bool?)
  @objc deinit
}
public protocol NodeServiceProtocol {
  func request<T>(httpMethod: Alamofire.HTTPMethod, method: Swift.String, parameters: [(any Swift.Encodable)?], chainInfo: ParticleNetworkChains.ChainInfo?) -> RxSwift.Single<Response<T>> where T : Swift.Decodable
}
public class NodeService : NodeServiceProtocol {
  public init()
  public func request<T>(httpMethod: Alamofire.HTTPMethod = .post, method: Swift.String = #function, parameters: [(any Swift.Encodable)?] = [], chainInfo: ParticleNetworkChains.ChainInfo? = nil) -> RxSwift.Single<Response<T>> where T : Swift.Decodable
  @objc deinit
}
public enum TronFormatAddress {
  public static func toHex(_ base58String: Swift.String) -> Swift.String
  public static func fromHex(_ hexString: Swift.String) -> Swift.String
}
@_inheritsConvenienceInitializers @objc public class ParticleNetwork : ObjectiveC.NSObject {
  @objc public static let sdkVersion: Swift.String
  public static var projectUuid: Swift.String {
    get
  }
  public static var projectClientKey: Swift.String {
    get
  }
  public static var projectAppUuid: Swift.String {
    get
  }
  @objc public static func initialize(config: ParticleNetworkConfiguration)
  @objc public static func initializeWithOptions(_ options: ParticleOptions, config: ParticleNetworkConfiguration)
  public static func setAAService(_ aaService: any AAServiceProtocol)
  public static func getAAService() -> (any AAServiceProtocol)?
  public static func setCustomUIConfigJsonString(_ jsonString: Swift.String) throws
  public static func setCustomUIConfig(_ uiConfig: CustomUIConfig)
  public static func getCustomUIConfig() -> CustomUIConfig?
  public static func setCountryFilter(filter: @escaping ((Country) -> Swift.Bool))
  public static func getCountryFilter() -> ((Country) -> Swift.Bool)?
  @objc public static func getChainInfo() -> ParticleNetworkChains.ChainInfo
  @objc public static func getDevEnv() -> ParticleNetwork.DevEnvironment
  @objc public static func setChainInfo(_ chainInfo: ParticleNetworkChains.ChainInfo)
  public static func setAppearance(_ style: UIKit.UIUserInterfaceStyle)
  public static func getAppearance() -> UIKit.UIUserInterfaceStyle
  public static func setThemeColor(_ color: UIKit.UIColor)
  public static func getThemeColor() -> UIKit.UIColor
  public static func setLanguage(_ language: Language)
  public static func getLanguage() -> Language
  public static func setFiatCoin(_ fiatCoin: FiatCoin)
  public static func getFiatCoin() -> FiatCoin?
  public static func setSecurityAccountConfig(config: SecurityAccountConfig)
  public static func getSecurityAccountConfig() -> SecurityAccountConfig
  public static func setAAAccountName(_ accountName: AA.AccountName)
  public static func getAAAccountName() -> AA.AccountName
  @objc override dynamic public init()
  @objc deinit
}
extension ParticleNetwork {
  @available(*, deprecated, renamed: "setAppearance")
  @objc public static func setInterfaceStyle(_ style: UIKit.UIUserInterfaceStyle)
  @available(*, deprecated, renamed: "getAppearance")
  @objc public static func getInterfaceStyle() -> UIKit.UIUserInterfaceStyle
}
@objc public class ParticleNetworkConfiguration : ObjectiveC.NSObject {
  @objc public init(chainInfo: ParticleNetworkChains.ChainInfo, devEnv: ParticleNetwork.DevEnvironment)
  @objc deinit
}
extension ParticleNetwork {
  @objc public enum DevEnvironment : Swift.Int {
    case debug
    case staging
    case production
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension ParticleNetwork {
  public static func searchChainInfo(by chainId: Swift.Int, chainType: ParticleNetworkChains.ChainType) -> ParticleNetworkChains.ChainInfo?
}
public enum Constant {
  public enum Regex {
    public static let base58PublicKey: Swift.String
    public static let base58String: Swift.String
    public static let evmAddress: Swift.String
    public static let tronAddress: Swift.String
    public static let hexString: Swift.String
    public static let email: Swift.String
    public static let phoneNumber: Swift.String
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Constants : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Regexs : ObjectiveC.NSObject {
    @objc public class func base58PublicKey() -> Swift.String
    @objc public class func base58String() -> Swift.String
    @objc public class func evmAddress() -> Swift.String
    @objc public class func hexString() -> Swift.String
    @objc public class func email() -> Swift.String
    @objc public class func phoneNumber() -> Swift.String
    @objc deinit
  }
  @objc deinit
}
public enum CountryHelper {
  public static let countries: [Country]
}
extension Foundation.TimeZone {
  public func offsetFromGMT() -> Swift.String
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ParticleOptions : ObjectiveC.NSObject {
  public init(projectUuid: Swift.String, projectClientKey: Swift.String, projectAppUuid: Swift.String)
  @objc deinit
}
extension Swift.String {
  public func urlEncoded() -> Swift.String
  public func urlDecoded() -> Swift.String
}
extension Swift.String {
  public var isAlphanumeric: Swift.Bool {
    get
  }
  public var isNumber: Swift.Bool {
    get
  }
  public var isDoubleNumber: Swift.Bool {
    get
  }
  public func isValidAddress() -> Swift.Bool
  public func isValidMessage() -> Swift.Bool
  public func isValidEmail() -> Swift.Bool
  public func isValidPhoneNumber() -> Swift.Bool
}
extension Swift.String {
  public func isValidSolanaAddress() -> Swift.Bool
  public func isValidEVMAddress() -> Swift.Bool
  public func isValidBase58String() -> Swift.Bool
  public func isValidHexString() -> Swift.Bool
  public func isValidTronAddress() -> Swift.Bool
}
extension Swift.Array where Element : Swift.Equatable {
  public mutating func appendIfNotExist(_ el: Element?)
  public mutating func appendOrReplace(_ el: Element?)
  public mutating func replace(_ el: Element?)
}
extension Swift.Int {
  public func toHexString() -> Swift.String
  public func toDateString() -> Swift.String
}
extension Swift.String {
  public func toBInt() -> BInt
  public func toChecksumAddress() -> Swift.String
}
public enum AA {
  @frozen public struct AccountName : Swift.Equatable, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    public static var allCases: [AA.AccountName] {
      get
    }
    public let version: Swift.String
    public let name: Swift.String
    public var walletName: Swift.String {
      get
    }
    public init(version: Swift.String, name: Swift.String)
    public static let biconomyV2: AA.AccountName
    public static let biconomyV1: AA.AccountName
    public static let simpleV1: AA.AccountName
    public static let simpleV2: AA.AccountName
    public static let cyberConnect: AA.AccountName
    public static let light: AA.AccountName
    public static let xterio: AA.AccountName
    public var image: UIKit.UIImage {
      get
    }
    public var isSupportBatchTx: Swift.Bool {
      get
    }
    public var supportChainIds: Swift.Set<Swift.Int> {
      get
    }
    public static func == (a: AA.AccountName, b: AA.AccountName) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [AA.AccountName]
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct AccountConfig : Swift.Codable {
    public var name: Swift.String
    public var version: Swift.String
    public var ownerAddress: Swift.String
    public init(name: Swift.String, version: Swift.String, ownerAddress: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  @frozen public enum FeeMode {
    case native
    case gasless
    case token(AA.FeeQuote)
  }
  public struct SmartAccountInfo : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable, Swift.Equatable {
    public var isDeployed: [Swift.Int : Swift.Bool]
    public var eoaAddress: Swift.String
    public var factoryAddress: Swift.String
    public var entryPointAddress: Swift.String
    public var smartAccountAddress: Swift.String
    public var fallBackHandlerAddress: Swift.String?
    public var implementationAddress: Swift.String?
    public var owner: Swift.String
    public var name: Swift.String
    public var version: Swift.String
    public var index: Swift.Int
    public init(from decoder: any Swift.Decoder) throws
    public init(isDeployed: [Swift.Int : Swift.Bool], eoaAddress: Swift.String, smartAccountAddress: Swift.String, index: Swift.Int, createdAt _: Swift.String, updatedAt _: Swift.String, entryPointAddress: Swift.String, factoryAddress: Swift.String, fallBackHandlerAddress: Swift.String, implementationAddress: Swift.String, owner: Swift.String, name: Swift.String, version: Swift.String)
    public init(from json: SwiftyJSON.JSON)
    public static func == (lhs: AA.SmartAccountInfo, rhs: AA.SmartAccountInfo) -> Swift.Bool
    public mutating func merge(_ other: AA.SmartAccountInfo)
    public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[AA.SmartAccountInfo]>
    public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<AA.SmartAccountInfo>
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public struct FeeQuote {
    public struct TokenInfo {
      public var chainId: Swift.Int
      public var symbol: Swift.String
      public var name: Swift.String
      public var decimals: Decimals
      public var logoURI: Swift.String
      public var address: Swift.String
      public var isNative: Swift.Bool {
        get
      }
    }
    public var tokenInfo: AA.FeeQuote.TokenInfo
    public var premiumPercentage: Swift.Int
    public var balance: BInt
    public var fee: BInt
    public var tokenPaymasterAddress: Swift.String?
    public var jsonObject: [Swift.String : SwiftyJSON.JSON]
    public init(json: SwiftyJSON.JSON, tokenPaymasterAddress: Swift.String?)
    public var isEnoughForPay: Swift.Bool {
      get
    }
  }
  public struct UserOp : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct WholeFeeQuote : Swift.Codable {
    public var gasless: AA.VerifyingPaymasterGasless?
    public var native: AA.VerifyingPaymasterNative
    public var token: AA.TokenPaymaster?
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VerifyingPaymasterGasless : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VerifyingPaymasterNative : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public var feeQuote: SwiftyJSON.JSON
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct TokenPaymaster : Swift.Codable {
    public var tokenPaymasterAddress: Swift.String
    public var feeQuotes: [SwiftyJSON.JSON]
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BInt {
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
  public func convertToBalanceBDouble(decimals: Swift.UInt8?) -> BDouble
  public func toHexString() -> Swift.String
  public func convertToScientific() -> Swift.String
}
extension BDouble {
  public func convertToScientific() -> Swift.String
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
}
@_hasMissingDesignatedInitializers @objc public class SupportAuthType : ObjectiveC.NSObject {
  public var rawValue: Swift.String
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public static var all: SupportAuthType {
    @objc get
  }
  @objc public static var google: SupportAuthType {
    @objc get
  }
  @objc public static var facebook: SupportAuthType {
    @objc get
  }
  @objc public static var apple: SupportAuthType {
    @objc get
  }
  @objc public static var twitter: SupportAuthType {
    @objc get
  }
  @objc public static var discord: SupportAuthType {
    @objc get
  }
  @objc public static var github: SupportAuthType {
    @objc get
  }
  @objc public static var twitch: SupportAuthType {
    @objc get
  }
  @objc public static var microsoft: SupportAuthType {
    @objc get
  }
  @objc public static var linkedin: SupportAuthType {
    @objc get
  }
  @objc public static var email: SupportAuthType {
    @objc get
  }
  @objc public static var phone: SupportAuthType {
    @objc get
  }
  @objc deinit
}
public enum LogEvent : Swift.String {
  case error
  case response
  case authService
  case walletService
  case connectService
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class Logger {
  public static var isEnableLogger: Swift.Bool
  open class func log(message: Any, event: LogEvent, tag: Swift.String, fileName: Swift.String = #file, line: Swift.Int = #line, column: Swift.Int = #column, funcName: Swift.String = #function, apiMethod _: Swift.String? = nil)
  public class func activeLog(data: Foundation.Data)
  public class func recordLog(data: Foundation.Data)
  public struct RecordObject : Swift.Encodable {
    public init(recordType: Logger.RecordType)
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case recordType
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public enum RecordType : Swift.String, Swift.Encodable {
    case pageLoginButtonClick
    case pageLoginSuccessBack
    case pageSignSuccessBack
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct ActiveObject : Swift.Encodable {
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case loginType
      case chainId
      case identity
      case walletAddress
      case action
      case userInfo
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public init(activeLoginType: Logger.ActiveLoginType, identity: Swift.String, walletAddress: Swift.String, activeActionType: Logger.ActiveActionType, userInfo: Swift.String?)
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public enum ActiveActionType : Swift.String {
    case login
    case open
    case openWallet
    case sign
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ActiveLoginType : Swift.String {
    case particle
    case private_key
    case metamask
    case rainbow
    case trust
    case imToken
    case bitget
    case phantom
    case other
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
public struct CustomUIConfig : Swift.Decodable {
  public var light: ModeConfig?
  public var dark: ModeConfig?
  public init(light: ModeConfig? = nil, dark: ModeConfig? = nil)
  public init(from decoder: any Swift.Decoder) throws
}
extension CustomUIConfig {
  public var accentColor: UIKit.UIColor? {
    get
  }
  public var accentColor_dark: UIKit.UIColor? {
    get
  }
  public var accentColor_light: UIKit.UIColor? {
    get
  }
  public var primaryButtonTextColor: UIKit.UIColor? {
    get
  }
  public var primaryButtonBackgroundColors: [UIKit.UIColor]? {
    get
  }
  public var primaryIconButtonBackgroundColors: [UIKit.UIColor]? {
    get
  }
  public var primaryIconButtonIconColor: UIKit.UIColor? {
    get
  }
  public var toastColor: (UIKit.UIColor?, UIKit.UIColor?) {
    get
  }
  public var maskColor: UIKit.UIColor? {
    get
  }
  public var textColor: UIKit.UIColor? {
    get
  }
  public var textColor_dark: UIKit.UIColor? {
    get
  }
  public var textColor_light: UIKit.UIColor? {
    get
  }
  public var textColorSecondary: UIKit.UIColor? {
    get
  }
  public var textColorSecondary_dark: UIKit.UIColor? {
    get
  }
  public var textColorSecondary_light: UIKit.UIColor? {
    get
  }
  public var textColorTertiary: UIKit.UIColor? {
    get
  }
  public var textColorTertiary_dark: UIKit.UIColor? {
    get
  }
  public var textColorTertiary_light: UIKit.UIColor? {
    get
  }
  public var backgroundColor: UIKit.UIColor? {
    get
  }
  public var backgroundColor_dark: UIKit.UIColor? {
    get
  }
  public var backgroundColor_light: UIKit.UIColor? {
    get
  }
  public var backgroundColorSecondary: UIKit.UIColor? {
    get
  }
  public var backgroundColorSecondary_dark: UIKit.UIColor? {
    get
  }
  public var backgroundColorSecondary_light: UIKit.UIColor? {
    get
  }
  public var backgroundColorTertiary: UIKit.UIColor? {
    get
  }
  public var backgroundColorTertiary_dark: UIKit.UIColor? {
    get
  }
  public var backgroundColorTertiary_light: UIKit.UIColor? {
    get
  }
  public var buttonTextColor: UIKit.UIColor? {
    get
  }
  public var buttonTextColor_dark: UIKit.UIColor? {
    get
  }
  public var buttonTextColor_light: UIKit.UIColor? {
    get
  }
  public var buttonBackgroundColor: UIKit.UIColor? {
    get
  }
  public var buttonBackgroundColor_dark: UIKit.UIColor? {
    get
  }
  public var buttonBackgroundColor_light: UIKit.UIColor? {
    get
  }
  public var cancelButtonTextColor: UIKit.UIColor? {
    get
  }
  public var cancelButtonTextColor_dark: UIKit.UIColor? {
    get
  }
  public var cancelButtonTextColor_light: UIKit.UIColor? {
    get
  }
  public var cancelButtonBackgroundColor: UIKit.UIColor? {
    get
  }
  public var cancelButtonBackgroundColor_dark: UIKit.UIColor? {
    get
  }
  public var cancelButtonBackgroundColor_light: UIKit.UIColor? {
    get
  }
}
public struct ModeConfig : Swift.Decodable {
  public var colorAccent: Swift.String?
  public var textColor: Swift.String?
  public var textColorSecondary: Swift.String?
  public var textColorTertiary: Swift.String?
  public var backgroundColor: Swift.String?
  public var backgroundColorSecondary: Swift.String?
  public var backgroundColorTertiary: Swift.String?
  public var buttonTextColor: Swift.String?
  public var buttonBackgroundColor: Swift.String?
  public var cancelButtonTextColor: Swift.String?
  public var cancelButtonBackgroundColor: Swift.String?
  public var primaryButtonBackgroundColors: [Swift.String]?
  public var primaryButtonTextColor: Swift.String?
  public var primaryIconButtonIconColor: Swift.String?
  public var primaryIconButtonBackgroundColors: [Swift.String]?
  public var messageColor: [Swift.String]?
  public var modalMaskBackgroundColor: Swift.String?
  public init(colorAccent: Swift.String? = nil, textColor: Swift.String? = nil, textColorSecondary: Swift.String? = nil, textColorTertiary: Swift.String? = nil, backgroundColor: Swift.String? = nil, backgroundColorSecondary: Swift.String? = nil, backgroundColorTertiary: Swift.String? = nil, buttonTextColor: Swift.String? = nil, buttonBackgroundColor: Swift.String? = nil, cancelButtonTextColor: Swift.String? = nil, cancelButtonBackgroundColor: Swift.String? = nil)
  public init(from decoder: any Swift.Decoder) throws
}
public enum FiatCoin : Swift.String, Swift.CaseIterable {
  case usd
  case cny
  case jpy
  case hkd
  case inr
  case krw
  public var symbol: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [FiatCoin]
  public typealias RawValue = Swift.String
  public static var allCases: [FiatCoin] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct Country {
  public let name: Swift.String
  public let iso: Swift.String
  public let code: Swift.Int
  public init(name: Swift.String, iso: Swift.String, code: Swift.Int)
  public func getFlagEmoji() -> Swift.String?
  public static func getCountryByPhoneNumber(phoneNumber: Swift.String) -> Country?
}
extension ParticleNetwork {
  public static var authEndPoint: Swift.String {
    get
  }
  public static var apiEndPoint: Swift.String {
    get
  }
  public static var nodeEndPoint: Swift.String {
    get
  }
  public static var webWalletEndPoint: Swift.String {
    get
  }
  public static var authCoreEndPoint: Swift.String {
    get
  }
}
extension SocialLoginPrompt : Swift.Equatable {}
extension SocialLoginPrompt : Swift.Hashable {}
extension UIKit.UIColor.WLNewColor : Swift.Equatable {}
extension UIKit.UIColor.WLNewColor : Swift.Hashable {}
extension UIKit.UIColor.ThemeColor : Swift.Equatable {}
extension UIKit.UIColor.ThemeColor : Swift.Hashable {}
extension UIKit.UIColor.ThemeColor : Swift.Sendable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.Equatable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.Hashable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.RawRepresentable {}
extension Action : Swift.Equatable {}
extension Action : Swift.Hashable {}
extension GasLevel : Swift.Equatable {}
extension GasLevel : Swift.Hashable {}
extension Language : Swift.Equatable {}
extension Language : Swift.Hashable {}
extension Language : Swift.RawRepresentable {}
extension LoginType : Swift.Equatable {}
extension LoginType : Swift.Hashable {}
extension LoginType : Swift.Sendable {}
extension Response.CodingKeys : Swift.Equatable {}
extension Response.CodingKeys : Swift.Hashable {}
extension Response.CodingKeys : Swift.RawRepresentable {}
extension UserInfo.CodingKeys : Swift.Equatable {}
extension UserInfo.CodingKeys : Swift.Hashable {}
extension UserInfo.CodingKeys : Swift.RawRepresentable {}
extension SecurityAccountInfo.CodingKeys : Swift.Equatable {}
extension SecurityAccountInfo.CodingKeys : Swift.Hashable {}
extension SecurityAccountInfo.CodingKeys : Swift.RawRepresentable {}
extension WalletInfo.CodingKeys : Swift.Equatable {}
extension WalletInfo.CodingKeys : Swift.Hashable {}
extension WalletInfo.CodingKeys : Swift.RawRepresentable {}
extension ThirdPartyWarpper.CodingKeys : Swift.Equatable {}
extension ThirdPartyWarpper.CodingKeys : Swift.Hashable {}
extension ThirdPartyWarpper.CodingKeys : Swift.RawRepresentable {}
extension ImagePath : Swift.Sendable {}
extension ParticleNetwork.DevEnvironment : Swift.Equatable {}
extension ParticleNetwork.DevEnvironment : Swift.Hashable {}
extension ParticleNetwork.DevEnvironment : Swift.RawRepresentable {}
extension AA.AccountName : Swift.Sendable {}
extension LogEvent : Swift.Equatable {}
extension LogEvent : Swift.Hashable {}
extension LogEvent : Swift.RawRepresentable {}
extension Logger.RecordObject.CodingKeys : Swift.Equatable {}
extension Logger.RecordObject.CodingKeys : Swift.Hashable {}
extension Logger.RecordObject.CodingKeys : Swift.RawRepresentable {}
extension Logger.RecordType : Swift.Equatable {}
extension Logger.RecordType : Swift.Hashable {}
extension Logger.RecordType : Swift.RawRepresentable {}
extension Logger.ActiveObject.CodingKeys : Swift.Equatable {}
extension Logger.ActiveObject.CodingKeys : Swift.Hashable {}
extension Logger.ActiveObject.CodingKeys : Swift.RawRepresentable {}
extension Logger.ActiveActionType : Swift.Equatable {}
extension Logger.ActiveActionType : Swift.Hashable {}
extension Logger.ActiveActionType : Swift.RawRepresentable {}
extension Logger.ActiveLoginType : Swift.Equatable {}
extension Logger.ActiveLoginType : Swift.Hashable {}
extension Logger.ActiveLoginType : Swift.RawRepresentable {}
extension FiatCoin : Swift.Equatable {}
extension FiatCoin : Swift.Hashable {}
extension FiatCoin : Swift.RawRepresentable {}
